#!/usr/bin/env python3

# stdlib
import sys
import argparse
import copy

# 3rd-party
import rospy
from colorama import Fore, Style
from std_msgs.msg import Header
from geometry_msgs.msg import Point, Pose, Vector3, Quaternion, TransformStamped, Transform
from visualization_msgs.msg import *
from localbot_localization.src.dataset import LocalBotDataset
import numpy as np
import tf2_ros

from scipy.spatial.transform import Rotation as R
from tf.transformations import *
from matplotlib import cm



def main():
    
    parser = argparse.ArgumentParser(description='Visualizing dataset')
    parser.add_argument('-dataset', '--dataset', type=str, required=True, help='Name of the training set')
    
    arglist = [x for x in sys.argv[1:] if not x.startswith('__')]
    args = vars(parser.parse_args(args=arglist))
    
    train_dataset = LocalBotDataset(path_seq=args['dataset'])
    
    rospy.init_node('visualize_dataset')
    rate = rospy.Rate(10) 
    
    marker_pub = rospy.Publisher("/marker_array", MarkerArray, queue_size=10)
    tf_broadcaster=tf2_ros.TransformBroadcaster()
    #colormap = cm.tab20(np.linspace(0, 1, len(train_dataset)))
                    
    while not rospy.is_shutdown():
        
        markers = MarkerArray()
        
        marker = Marker(header=Header(frame_id="map", stamp=rospy.Time.now()),
                        id=0, frame_locked=False,
                        type=Marker.MESH_RESOURCE, action=Marker.ADD, lifetime=rospy.Duration(0),
                        pose=Pose(position=Point(x=0, y=0, z=0), orientation=Quaternion(x=0, y=0, z=0, w=1)),
                        scale=Vector3(x=1.0, y=1.0, z=1.0))
        marker.mesh_resource = 'package://localbot_gazebo/models/room_024/room_024.dae'
        marker.mesh_use_embedded_materials = True
        markers.markers.append(marker)
        
        
        for idx in range(len(train_dataset)):
        
            # publish markers
            _, pose = train_dataset[idx]
            
            ######  REAL ########
            
            # Rotate orientation because the arrow points to the X-axis! (it must point to Z-axis)
            pose_marker = copy.deepcopy(pose)
            matrix_quaternion_marker =R.from_quat(pose_marker[3:]).as_matrix()
            rotate_y90 = R.from_euler('y', -90, degrees=True).as_matrix()
            matrix_quaternion_marker = np.dot(matrix_quaternion_marker,rotate_y90)
            quaternion_marker = R.from_matrix(matrix_quaternion_marker).as_quat()
            
            marker = Marker(header=Header(frame_id="map", stamp=rospy.Time.now()))
            marker.type = marker.ARROW
            marker.action = marker.ADD
            marker.scale.x = 0.3
            marker.scale.y = 0.05
            marker.scale.z = 0.05
            marker.color.a = 0.8
            marker.color.r = 0.3
            marker.color.g = 0.6
            marker.color.b = 0.3
            marker.pose.orientation.x = quaternion_marker[0]
            marker.pose.orientation.y = quaternion_marker[1]
            marker.pose.orientation.z = quaternion_marker[2]
            marker.pose.orientation.w = quaternion_marker[3]
            marker.pose.position.x = pose[0]
            marker.pose.position.y = pose[1]
            marker.pose.position.z = pose[2]
            marker.ns = 'real'
            marker.id = idx
            
            markers.markers.append(marker)
            
            ######  PREDICTED  ########
            
            ## DEBUG
            # if idx==0:
            #     transform = TransformStamped(header=Header(frame_id="map", stamp=rospy.Time.now()),
            #                                         child_frame_id=f'frame{idx}',
            #                                         transform=Transform(translation=Vector3(x=pose[0], y=pose[1], z=pose[2]),
            #                                                             rotation=Quaternion(x=pose[3], y=pose[4], z=pose[5], w=pose[6])))
            #     tf_broadcaster.sendTransform(transform)
            
       
        marker_pub.publish(markers)       
        rate.sleep()
        
        
        
    
    
if __name__ == "__main__":
    main()



