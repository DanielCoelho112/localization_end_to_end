#!/usr/bin/env python3

# stdlib
from math import degrees
import sys
import argparse
from turtle import stamp
import copy

from matplotlib.pyplot import axis
from sympy import degree

# 3rd-party
import rospy
from colorama import Fore, Style
from std_msgs.msg import Header, ColorRGBA
from geometry_msgs.msg import Point, Pose, Vector3, Quaternion, TransformStamped, Transform
from visualization_msgs.msg import *
from localbot_localization.src.results import LocalBotResults
import numpy as np
import tf2_ros

from scipy.spatial.transform import Rotation as R
from tf.transformations import *
from matplotlib import cm



def main():
    
    # parser = argparse.ArgumentParser(description='Data Collector')
    # parser.add_argument('-m', '--mode', type=str, default='interactive', help='interactive/automatic_random_path/automatic_path')
    # parser.add_argument('-s', '--seq', type=int, default=10, help='sequence number')
    # parser.add_argument('-ns', '--n_steps', type=int, default=20, help='number of steps')
    # parser.add_argument('-dp', '--destination_pose', type=str, default='x,y,z,rx,ry,rz', help='destination pose')
    # arglist = [x for x in sys.argv[1:] if not x.startswith('__')]
    # args = vars(parser.parse_args(args=arglist))
    
    results = LocalBotResults('test1')
    rospy.init_node('visualize_results')
    rate = rospy.Rate(10) 
    
    marker_mesh = rospy.Publisher("/room_024", Marker, queue_size=10)
    marker_pose = rospy.Publisher("/poses", Marker, queue_size=10)
    tf_broadcaster=tf2_ros.TransformBroadcaster()
    idx = 0
    colormap = cm.tab20(np.linspace(0, 1, len(results)))
    
    
    from pyquaternion import Quaternion
                    
    while not rospy.is_shutdown():
        
        if idx == len(results)-1:
            idx = 0
            
        marker = Marker(header=Header(frame_id="map", stamp=rospy.Time.now()),
                    id=0, frame_locked=False,
                    type=Marker.MESH_RESOURCE, action=Marker.ADD, lifetime=rospy.Duration(0),
                    pose=Pose(position=Point(x=0, y=0, z=0), orientation=Quaternion(x=0, y=0, z=0, w=1)),
                    scale=Vector3(x=1.0, y=1.0, z=1.0))
        marker.mesh_resource = 'package://localbot_gazebo/models/room_024/room_024.dae'
        marker.mesh_use_embedded_materials = True
        marker_mesh.publish(marker)
        
        # publish markers
        pose_real, pose_predicted = results[idx]
        
        ######  REAL ########
        
        # Rotate orientation because the arrow points to the X-axis! (it must point to Z-axis)
        pose_real_marker = copy.deepcopy(pose_real)
        matrix_quaternion_marker =R.from_quat(pose_real_marker[3:]).as_matrix()
        rotate_y90 = R.from_euler('y', -90, degrees=True).as_matrix()
        matrix_quaternion_marker = np.dot(matrix_quaternion_marker,rotate_y90)
        quaternion_marker = R.from_matrix(matrix_quaternion_marker).as_quat()
        

        marker = Marker(header=Header(frame_id="map", stamp=rospy.Time.now()))
        marker.type = marker.ARROW
        marker.action = marker.ADD
        marker.scale.x = 0.3
        marker.scale.y = 0.05
        marker.scale.z = 0.05
        marker.color.a = 0.8
        marker.color.r = colormap[idx][0]
        marker.color.g = colormap[idx][1]
        marker.color.b = colormap[idx][2]
        marker.pose.orientation.x = quaternion_marker[0]
        marker.pose.orientation.y = quaternion_marker[1]
        marker.pose.orientation.z = quaternion_marker[2]
        marker.pose.orientation.w = quaternion_marker[3]
        marker.pose.position.x = pose_real[0]
        marker.pose.position.y = pose_real[1]
        marker.pose.position.z = pose_real[2]
        marker.ns = 'real'
        marker.id = idx
        
        marker_pose.publish(marker)
        
        ######  PREDICTED  ########
        
        pose_predicted_marker = copy.deepcopy(pose_predicted)
        matrix_quaternion_marker =R.from_quat(pose_predicted_marker[3:]).as_matrix()
        rotate_y90 = R.from_euler('y', -90, degrees=True).as_matrix()
        matrix_quaternion_marker = np.dot(matrix_quaternion_marker,rotate_y90)
        quaternion_marker = R.from_matrix(matrix_quaternion_marker).as_quat()
        
        marker = Marker(header=Header(frame_id="map", stamp=rospy.Time.now()))
        marker.type = marker.ARROW
        marker.action = marker.ADD
        marker.scale.x = 0.10
        marker.scale.y = 0.05
        marker.scale.z = 0.05
        marker.color.a = 0.5
        marker.color.r = colormap[idx][0]
        marker.color.g = colormap[idx][1]
        marker.color.b = colormap[idx][2]
        marker.pose.orientation.x = quaternion_marker[0]
        marker.pose.orientation.y = quaternion_marker[1]
        marker.pose.orientation.z = quaternion_marker[2]
        marker.pose.orientation.w = quaternion_marker[3]
        marker.pose.position.x = pose_predicted[0]
        marker.pose.position.y = pose_predicted[1]
        marker.pose.position.z = pose_predicted[2]
        marker.ns = 'predicted'
        marker.id = idx
        
        marker_pose.publish(marker)
        
        
        if idx==9:
            transform = TransformStamped(header=Header(frame_id="map", stamp=rospy.Time.now()),
                                                child_frame_id=f'frame{idx}',
                                                transform=Transform(translation=Vector3(x=pose_real[0], y=pose_real[1], z=pose_real[2]),
                                                                    rotation=Quaternion(x=pose_real[3], y=pose_real[4], z=pose_real[5], w=pose_real[6])))
            tf_broadcaster.sendTransform(transform)
        
       
        
        idx+=1
        
        rate.sleep()
        
        
        
    
    
if __name__ == "__main__":
    main()



